# -*- coding: utf-8 -*-
"""Smart Recipe Scaler

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1921_RzjB-_6YUi-67Q8WWsCs713XALNU
"""

def scale_recipe():
    """
    Calculates and scales ingredient quantities based on changes in serving size.
    This program runs a loop to ask for ingredients until the user types 'done'.

    This function demonstrates key Python concepts for beginners:
    1. Input validation using try-except blocks to prevent crashes.
    2. Basic arithmetic for calculating the scaling factor.
    3. Looping (`while True`) to process multiple items.
    4. Storing structured data using lists of dictionaries.
    5. Simple output formatting for clean presentation.
    """
    print("---------------------------------------------")
    print("        \U0001F373 Smart Recipe Scaler \U0001F373        ")
    print("---------------------------------------------")

    # --- 1. Get Initial Serving Information (With Input Validation) ---
    try:
        # Get the initial number of servings from the user. We convert the input
        # to a floating-point number (float) to handle decimals like 4.5 servings.
        original_servings = float(input("Enter the ORIGINAL number of servings the recipe makes (e.g., 4): "))

        # Check to ensure the user entered a positive number.
        if original_servings <= 0:
            print("Error: The original number of servings must be a positive number. Exiting.")
            return

        # Get the desired number of servings the user wants to make.
        desired_servings = float(input("Enter the DESIRED number of servings you want to make (e.g., 10): "))

        # Check to ensure the desired number is also positive.
        if desired_servings <= 0:
            print("Error: The desired number of servings must be a positive number. Exiting.")
            return

    except ValueError:
        # If the user enters text instead of a number (e.g., "four"), a ValueError occurs.
        # This block catches it and provides a friendly error message, preventing the program from crashing.
        print("\n\U0001F525 Error: Please enter valid numerical values for servings (e.g., 4, 10.5). Exiting.")
        return

    # Calculate the scaling factor: This is the multiplier for every ingredient quantity.
    # Example: If original=4 and desired=10, the factor is 10/4 = 2.5.
    scaling_factor = desired_servings / original_servings
    print(f"\nCalculated Scaling Factor: {scaling_factor:.2f} (Every quantity will be multiplied by this number)")

    # This list will store dictionaries (a collection of key:value pairs),
    # each containing the scaled name, quantity, and unit of one ingredient.
    scaled_ingredients = []

    # --- 2. Collect and Scale Ingredients in a Loop ---
    print("\n--- Enter Ingredients (Type 'done' for ingredient name to finish) ---")

    while True:
        # Get the name of the ingredient from the user.
        ingredient_name = input("Ingredient Name (e.g., 'Flour', 'Sugar') or type 'done': ").strip()

        # Stop the loop if the user signals they are finished.
        if ingredient_name.lower() == 'done':
            break

        try:
            # Get the original quantity for the ingredient and convert it to a float.
            original_quantity = float(input(f"  Enter original quantity for {ingredient_name} (e.g., 2.5): "))

            # Get the unit of measurement (e.g., 'cups', 'g', 'tsp').
            unit = input(f"  Enter unit (e.g., 'cups', 'g', 'tsp'): ").strip()

            # Validation check: quantity must be non-negative.
            if original_quantity < 0:
                print("  Quantity must be non-negative. Skipping this ingredient.\n")
                continue

            # Core Calculation: Apply the scaling factor
            new_quantity = original_quantity * scaling_factor

            # Round the new quantity to two decimal places for practical measurement
            # (e.g., a quantity of 1.23456 becomes 1.23).
            new_quantity_rounded = round(new_quantity, 2)

            # Store the result in our list as a dictionary object.
            scaled_ingredients.append({
                'name': ingredient_name,
                'new_qty': new_quantity_rounded,
                'unit': unit
            })
            print(f"  -> Success! New quantity calculated: {new_quantity_rounded} {unit}\n")

        except ValueError:
            # Catch error if the user inputs text for the quantity instead of a number.
            print("\n\U0001F525 Error: Please enter a valid numerical quantity for the ingredient. Try again.\n")
        except Exception as e:
            # Catch any other unexpected errors and print them.
            print(f"  An unexpected error occurred: {e}. Skipping ingredient.\n")


    # --- 3. Display the Final Scaled Recipe ---
    print("\n=============================================")
    # The {:.0f} formatting ensures the serving number is displayed as a whole number.
    print(f"   \U0001F37D Scaled Recipe for {desired_servings:.0f} Servings   ")
    print("=============================================")

    if not scaled_ingredients:
        print("No ingredients were entered to scale.")
        return

    # Loop through the final list and print each item.
    for item in scaled_ingredients:
        # Convert the quantity to a string and use rstrip() to remove trailing '.0'
        # if the number is a whole number (e.g., 5.0 becomes 5). This makes the output cleaner!
        qty_display = str(item['new_qty']).rstrip('0').rstrip('.')

        # Print with neat alignment using f-string formatting. The <6 and <8 mean
        # "left-align this item within a space of 6 (or 8) characters."
        print(f"  {qty_display:<6} {item['unit']:<8} of {item['name']}")

    print("=============================================")
    scale_recipe()
